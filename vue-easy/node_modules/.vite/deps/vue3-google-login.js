import {
  createCommentVNode,
  createElementBlock,
  defineComponent,
  onMounted,
  openBlock,
  reactive,
  ref,
  renderSlot,
  unref,
  useSlots,
  watch
} from "./chunk-EYMNJ3H6.js";
import "./chunk-CF3WPAMV.js";

// node_modules/vue3-google-login/dist/index.esm.js
var s = Object.freeze({ __proto__: null });
var u = { library: "https://accounts.google.com/gsi/client", defaultButtonConfig: { theme: "outline", size: "large" }, scopes: "email profile openid" };
var g = reactive({ clientId: null, popupType: "CODE", prompt: false, autoLogin: false, idConfiguration: null, buttonConfig: u.defaultButtonConfig, callback: () => {
}, error: null });
var f = reactive({ apiLoaded: false, apiLoadIntitited: false });
var b = (e) => {
  try {
    const t = e.split(".")[1].replace(/-/g, "+").replace(/_/g, "/"), o = decodeURIComponent(atob(t).split("").map(function(e2) {
      return "%" + ("00" + e2.charCodeAt(0).toString(16)).slice(-2);
    }).join(""));
    return JSON.parse(o);
  } catch (e2) {
    throw "JWT provided is invalid";
  }
};
var m = new Promise((e) => {
  const t = "undefined" != typeof window;
  if (!f.apiLoadIntitited && t) {
    const t2 = document.createElement("script");
    f.apiLoadIntitited = true, t2.addEventListener("load", () => {
      f.apiLoaded = true, e(window.google);
    }), t2.src = u.library, t2.async = true, t2.defer = true, document.head.appendChild(t2);
  }
});
var w = (e) => {
  f.apiLoadIntitited ? f.apiLoaded ? e(window.google) : watch(() => f.apiLoaded, (t) => {
    t && e(window.google);
  }) : m.then((t) => {
    e(t);
  });
};
var I = (e, t, o, i) => {
  if (!e.client_id)
    throw new Error("Prop client id required since plugin is not initialized with a client id");
  w(() => {
    ((e2, t2, o2, i2, n) => {
      if (n) {
        const t3 = e2.callback;
        e2.callback = (e3) => {
          e3.credential ? t3 && t3(e3) : n(e3);
        };
      }
      window.google.accounts.id.initialize(e2);
      const l = t2.value;
      l && !i2 && window.google.accounts.id.renderButton(l, o2);
    })(e, t, o.buttonConfig, i, o.error), o.prompt && k({ clientId: o.clientId, callback: o.callback, error: o.error, autoLogin: o.autoLogin });
  });
};
var y = (e) => new Promise((t, o) => {
  w((i) => {
    if (!(e && e.clientId || g.clientId))
      throw new Error("clientId is required since the plugin is not initialized with a Client Id");
    i.accounts.oauth2.initCodeClient({ client_id: e && e.clientId || g.clientId || "", scope: u.scopes, ux_mode: "popup", callback: (e2) => {
      e2.code ? t(e2) : o(e2);
    }, error_callback: (e2) => {
      o(e2);
    } }).requestCode();
  });
});
var h = (e) => new Promise((t, o) => {
  w((i) => {
    if (!(e && e.clientId || g.clientId))
      throw new Error("clientId is required since the plugin is not initialized with a Client Id");
    i.accounts.oauth2.initTokenClient({ client_id: e && e.clientId || g.clientId || "", scope: u.scopes, callback: (e2) => {
      e2.access_token ? t(e2) : o(e2);
    }, error_callback: (e2) => {
      o(e2);
    } }).requestAccessToken();
  });
});
var k = (e) => {
  if (!e && (e = {}), !e.clientId && !g.clientId)
    throw new Error("clientId is required");
  const t = {};
  return e.clientId && (t.client_id = e.clientId), !e.clientId && g.clientId && (t.client_id = g.clientId), e.context && (t.context = e.context), null != e.autoLogin && (t.auto_select = e.autoLogin), null != e.cancelOnTapOutside && (t.cancel_on_tap_outside = e.cancelOnTapOutside), new Promise((o, i) => {
    t.callback = (t2) => {
      e && e.callback && e.callback(t2), t2.credential ? o(t2) : i(t2);
    }, w((o2) => {
      o2.accounts.id.initialize(t), o2.accounts.id.prompt((t2) => {
        e && e.onNotification && e.onNotification(t2), ((e2) => {
          const t3 = e2.notification;
          let o3 = "";
          t3.isNotDisplayed() && (o3 = "suppressed_by_user" === t3.getNotDisplayedReason() ? "Prompt was suppressed by user'. Refer https://developers.google.com/identity/gsi/web/guides/features#exponential_cooldown for more info" : `Prompt was not displayed, reason for not displaying: ${t3.getNotDisplayedReason()}`), t3.isSkippedMoment() && (o3 = `Prompt was skipped, reason for skipping: ${t3.getSkippedReason()}`), o3.length && (e2.error ? e2.error(o3) : e2.reject(o3));
        })({ notification: t2, reject: i, error: e && e.error });
      });
    });
  });
};
var _ = () => {
  w((e) => {
    e.accounts.id.disableAutoSelect();
  });
};
var C = defineComponent({ name: "GoogleLogin", props: { clientId: { type: String, required: false }, prompt: { type: Boolean, required: false, default: false }, autoLogin: { type: Boolean, required: false, default: false }, popupType: { type: String, required: false }, idConfiguration: { type: Object, required: false }, buttonConfig: { type: Object, required: false }, callback: { type: Function, required: false }, error: { type: Function, required: false } }, setup(e) {
  const t = e, o = !!useSlots().default, s2 = ((e2, t2) => {
    const o2 = { ...e2 };
    for (const e3 in t2)
      void 0 !== t2[e3] && null !== t2[e3] && (o2[e3] = t2[e3]);
    return o2;
  })(g, t), u2 = { client_id: s2.clientId || null, auto_select: s2.autoLogin || false, callback: s2.callback, ...s2.idConfiguration }, f2 = ref();
  return onMounted(() => {
    I(u2, f2, s2, o), t.popupType && !o && console.warn("Option 'popupType' is ignored since a slot which act as a custom login button was not found!!!");
  }), (e2, t2) => (openBlock(), createElementBlock("div", { class: "g-btn-wrapper", onClick: t2[0] || (t2[0] = (e3) => unref(o) && void ("TOKEN" === unref(s2).popupType ? h({ clientId: s2.clientId }).then((e4) => {
    s2.callback && s2.callback(e4);
  }).catch((e4) => {
    s2.error && s2.error(e4);
  }) : y({ clientId: s2.clientId }).then((e4) => {
    s2.callback && s2.callback(e4);
  }).catch((e4) => {
    s2.error && s2.error(e4);
  }))) }, [unref(o) ? createCommentVNode("v-if", true) : (openBlock(), createElementBlock("span", { key: 0, ref_key: "buttonRef", ref: f2, class: "g-btn" }, null, 512)), renderSlot(e2.$slots, "default")]));
} });
!function(e, t) {
  void 0 === t && (t = {});
  var o = t.insertAt;
  if (e && "undefined" != typeof document) {
    var i = document.head || document.getElementsByTagName("head")[0], n = document.createElement("style");
    n.type = "text/css", "top" === o && i.firstChild ? i.insertBefore(n, i.firstChild) : i.appendChild(n), n.styleSheet ? n.styleSheet.cssText = e : n.appendChild(document.createTextNode(e));
  }
}("\n.g-btn-wrapper[data-v-5e610566] {\n  display: inline-block;\n}\n"), C.__scopeId = "data-v-5e610566", C.__file = "src/plugin/GoogleLogin.vue";
var L = { install: (e, t) => {
  t && ((e2) => {
    e2.clientId && (g.clientId = e2.clientId), e2.popupType && (g.popupType = e2.popupType), null != e2.prompt && (g.prompt = e2.prompt), null != e2.autoLogin && (g.autoLogin = e2.autoLogin), e2.idConfiguration && (g.idConfiguration = e2.idConfiguration), e2.buttonConfig && (g.buttonConfig = e2.buttonConfig), e2.callback && (g.callback = e2.callback);
  })(t), m.then(() => {
    if (t.clientId) {
      const e2 = { client_id: t.clientId, auto_select: true === t.autoLogin, callback: t.callback, use_fedcm_for_prompt: true, ...t.idConfiguration };
      window.google.accounts.id.initialize(e2), t.prompt && window.google.accounts.id.prompt();
    }
  }), e.component("GoogleLogin", C);
} };
export {
  s as CallbackTypes,
  C as GoogleLogin,
  b as decodeCredential,
  L as default,
  y as googleAuthCodeLogin,
  _ as googleLogout,
  k as googleOneTap,
  w as googleSdkLoaded,
  h as googleTokenLogin
};
//# sourceMappingURL=vue3-google-login.js.map
